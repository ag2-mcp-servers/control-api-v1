# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T08:57:33+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, HTTPBearer
from fastapi import UploadFile

from models import (
    AccountsAccountIdAppsGetResponse,
    AppPatch,
    AppPost,
    AppResponse,
    AppsAppIdKeysGetResponse,
    AppsAppIdNamespacesGetResponse,
    AppsAppIdQueuesGetResponse,
    AppsAppIdRulesGetResponse,
    Error,
    KeyPatch,
    KeyPost,
    KeyResponse,
    Me,
    NamespacePatch,
    NamespacePost,
    NamespaceResponse,
    Queue,
    QueueResponse,
    RulePatch,
    RulePost,
    RuleResponse,
)

app = MCPProxy(
    contact={'x-twitter': 'ablyrealtime'},
    description='Use the Control API to manage your applications, namespaces, keys, queues, rules, and more.\n\nDetailed information on using this API can be found in the Ably <a href="https://ably.com/documentation/control-api">developer documentation</a>.\n\nControl API is currently in Beta.\n',
    title='Control API v1',
    version='1.0.14',
    servers=[{'url': 'https://control.ably.net/v1'}],
)


@app.get(
    '/accounts/{account_id}/apps',
    description=""" List all applications for the specified account ID. """,
    tags=['account_app_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_accounts__account_id_apps(account_id: str):
    """
    Lists apps
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/accounts/{account_id}/apps',
    description=""" Creates an application with the specified properties. """,
    tags=['account_app_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_accounts__account_id_apps(account_id: str, body: AppPost = None):
    """
    Creates an app
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{app_id}/keys',
    description=""" Lists the API keys associated with the application ID. """,
    tags=['app_key_management', 'account_app_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_apps__app_id_keys(app_id: str):
    """
    Lists app keys
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{app_id}/keys',
    description=""" Creates an API key for the application specified. """,
    tags=['app_key_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_apps__app_id_keys(app_id: str, body: KeyPost = None):
    """
    Creates a key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/apps/{app_id}/keys/{key_id}',
    description=""" Update the API key with the specified key ID, for the application with the specified application ID. """,
    tags=['app_key_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def patch_apps__app_id_keys__key_id(
    app_id: str, key_id: str = ..., body: KeyPatch = None
):
    """
    Updates a key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{app_id}/keys/{key_id}/revoke',
    description=""" Revokes the API key with the specified ID, with the Application ID. This deletes the key. """,
    tags=['app_key_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_apps__app_id_keys__key_id_revoke(app_id: str, key_id: str = ...):
    """
    Revokes a key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{app_id}/namespaces',
    description=""" List the namespaces for the specified application ID. """,
    tags=['app_namespace_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_apps__app_id_namespaces(app_id: str):
    """
    Lists namespaces
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{app_id}/namespaces',
    description=""" Creates a namespace for the specified application ID. """,
    tags=['app_namespace_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_apps__app_id_namespaces(app_id: str, body: NamespacePost = None):
    """
    Creates a namespace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{app_id}/namespaces/{namespace_id}',
    description=""" Deletes the namespace with the specified ID, for the specified application ID. """,
    tags=['app_namespace_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_apps__app_id_namespaces__namespace_id(app_id: str, namespace_id: str = ...):
    """
    Deletes a namespace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/apps/{app_id}/namespaces/{namespace_id}',
    description=""" Updates the namespace with the specified ID, for the application with the specified application ID. """,
    tags=['app_namespace_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def patch_apps__app_id_namespaces__namespace_id(
    app_id: str, namespace_id: str = ..., body: NamespacePatch = None
):
    """
    Updates a namespace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{app_id}/queues',
    description=""" Lists the queues associated with the specified application ID. """,
    tags=['app_queue_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_apps__app_id_queues(app_id: str):
    """
    Lists queues
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{app_id}/queues',
    description=""" Creates a queue for the application specified by application ID. The properties for the queue to be created are specified in the request body. """,
    tags=['app_queue_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_apps__app_id_queues(app_id: str, body: Queue = None):
    """
    Creates a queue
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{app_id}/queues/{queue_id}',
    description=""" Delete the queue with the specified queue name, from the application with the specified application ID. """,
    tags=['app_queue_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_apps__app_id_queues__queue_id(app_id: str, queue_id: str = ...):
    """
    Deletes a queue
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{app_id}/rules',
    description=""" Lists the rules for the application specified by the application ID. """,
    tags=['app_rule_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_apps__app_id_rules(app_id: str):
    """
    Lists Reactor rules
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{app_id}/rules',
    description=""" Creates a rule for the application with the specified application ID. """,
    tags=['app_rule_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_apps__app_id_rules(app_id: str, body: RulePost = None):
    """
    Creates a Reactor rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{app_id}/rules/{rule_id}',
    tags=['app_rule_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_apps__app_id_rules__rule_id(app_id: str, rule_id: str = ...):
    """
    Deletes a Reactor rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{app_id}/rules/{rule_id}',
    description=""" Returns the rule specified by the rule ID, for the application specified by application ID. """,
    tags=['app_rule_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_apps__app_id_rules__rule_id(app_id: str, rule_id: str = ...):
    """
    Gets a reactor rule by rule ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/apps/{app_id}/rules/{rule_id}',
    tags=['app_rule_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def patch_apps__app_id_rules__rule_id(
    app_id: str, rule_id: str = ..., body: RulePatch = None
):
    """
    Updates a Reactor rule
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{id}',
    description=""" Deletes the application with the specified application ID. """,
    tags=['account_app_management', 'application_deletion_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def delete_apps__id(id: str):
    """
    Deletes an app
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/apps/{id}',
    description=""" Updates the application with the specified application ID. """,
    tags=['account_app_management', 'application_deletion_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def patch_apps__id(id: str, body: AppPatch = None):
    """
    Updates an app
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{id}/pkcs12',
    description=""" Updates the application's Apple Push Notification service (APNs) information. """,
    tags=['account_app_management', 'app_key_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def post_apps__id_pkcs12(id: str, file: UploadFile = ...):
    """
    Updates app's APNs info from a `.p12` file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me',
    tags=['token_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def get_me():
    """
    Get token details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
